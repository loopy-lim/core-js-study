# datatype

생성일: 2022년 9월 15일 오전 2:16

# 1-1 데이터 타입의 종류

## 1. 기본형(primitive type)

→ **값이 담긴 주솟값**을 바로 복제

- 숫자 number
- 문자열 string
- 불리언 boolean
- null
- undefined
- 심볼 symbol

## 2. 참조형(object type)

→ 값이 담긴 주솟값들로 이루어진 **묶음을 가리키는 주솟값**을 복제

- 객체 object
- 배열 array
- 함수 function
- 날짜 date
- 정규표현식 RegExp
- Map, WeakMap
- Set, WeakSet

# 1-2 데이터 타입에 관한 배경지식

## 1-2-1 메모리와 데이터

**비트**: 0 또는 1만 표현할 수 있는 하나의 메모리 조각

→ 고유한 식별자를 통해 위치 확인 가능

**바이트**: 8개의 비트로 구성, 1비트마다 0 또는 1의 두 가지 값 표현 가능 (2의 8승)

→ 시작하는 비트의 식별자로 위치 파악

- **모든 데이터**는 메모리 주솟값을 통해 서로 구분하고 연결할 수 있다.
- js는 정수형인지 부동소수형인지 구분하지 않고 64비트(8바이트) 확보

## 1-2-2 식별자와 변수

- 변수: 변할 수 있는 데이터(숫자, 문자열, 객체, 배열)
- 식별자(변수명): 데이터를 식별하는데 사용하는 이름

# 1-3 변수 선언과 데이터 할당

## 1-3-1 변수 선언

- 변수: 변경 가능한 데이터가 담길 수 있는 공간 또는 그릇

### **변수 선언 동작 원리**

변수 선언 → 메모리에서 비어있는 공간 하나 확보 → 이 공간의 이름(식별자) 지정

## 1-3-2 데이터 할당

### **데이터 할당 동작 원리**

1. 변수 영역에서 빈 공간을 확보한다.
2. 확보한 공간의 식별자를 a로 지정한다.
3. 데이터 영역의 빈 공간에 문자열 ‘abc’를 지정한다.
4. 변수 영역에서 a라는 식별자를 검색한다.
5. 앞서 저장한 문자열의 주소를 a 식별자 공간에 대입한다.

- 데이터 할당 방식의 장점 및 특징
    - 데이터 변환을 자유롭게 할 수 있게 함
    - 메모리를 더욱 효율적으로 관리하기 위함
    - 문자열은 특별히 정해진 규격이 없음(가변적)
    - 데이터를 새로 할당하려하면 별도의 공간을 새로 만들어 저장하여, 그 주소를 변수 공간에 연결함.

# 1-4 기본형 데이터와 참조형 데이터

## 1-4-1 불변값

변수 vs 상수: 변경가능성으로 구분

- 변경가능성의 대상: 변수 영역 메모리

→ 한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부

불변값 vs 상수: 불변성 여부로 구분

- 불변성 여부를 구분하는 변경 가능성의 대상: 데이터 영역 메모리
- 불변값의 성질: 변경은 새로 만드는 동작을 통해서만 이뤄짐.(ex. 숫자, 문자열, boolean, null, undefined, symbol)
- 한 번 만들어진 값은 가비지컬렉팅을 당하지 않는 한 영원히 변하지 않음.

## 1-4-2 가변값

- `객체의 변수(프로퍼티)` 영역이 별도로 존재함.
- 객체가 별도로 할애한 영역은 변수 영역일 뿐 **데이터 영역은 기존의 메모리 공간을 그대로 활용**함.
- 참조형 데이터의 프로퍼티 재할당: 새로운 객체가 만들어진 것이 아니라 **기존의 객체 내부의 값만 바뀜**.

**참조 카운트:** 어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수

참조 카운트가 0인 메모리 주소는 **가비지 컬렉터(GC)의 수거 대상**

- 특정 시점이나 메모리 사용량이 포화상태에 임박할 때마다 자동으로 수거

**중첩객체**: 참조형 데이터의 프로퍼티에 다시 참조형 데이터를 할당하는 경우

## 1-4-3 변수 복사 비교

### 변수 선언 및 할당 과정

- 기본형 데이터
    1. 변수 영역의 빈 공간 확보
    2. 식별자 지정
    3. 값을 데이터 영역에서 검색 
        1. 없으면 빈공간에 저장
        2. 존재하면 변수영역의 값에 데이터 영역의 주솟값 저장
- 참조형 데이터
    1. 변수 영역의 빈 공간 확보
    2. 식별자 지정
    3. 데이터 영역의 빈 공간 확보
    4. 데이터 영역의 데이터에 별도의 변수영역의 주솟값 저장
    5. 그 변수영역에 각각 식별자마다 값 지정하여 연결
    

공통점: 변수를 복사하는 과정에서 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 됨.

차이점: 

- 기본형 데이터: 다른 값으로 복사했을 때 데이터의 주솟값이 달라짐.
- 참조형 데이터: 객체의 주솟값이 달라지는 것이 아니라 객체 프로퍼티 값의 주솟값이 달라짐. 따라서 데이터의 주솟값(객체의 주솟값)은 달라지지 않음.

```jsx
var a = 10;
var b = a;
var obj1 = { c: 10, d: 'ddd' };
var obj2 = obj1;

b = 15;
obj2.c = 20; //객체의 프로퍼티를 변경하는 경우
```

주솟값은 다음과 같다.

```jsx
a != b
obj1 === obj2
```

- 기본형은 주솟값을 복사하는 과정이 한 번만 이루어짐.
- 참조형은 객체의 프로퍼티의 주솟값이 달라지기 때문에 한 단계를 더 거치게 됨.

```jsx
obj2 = { c: 20, d: 'ddd' } //객체 자체를 변경했을 때
```

- 다음의 경우는 객체 자체를 변경하므로 데이터의 주솟값도 달라짐.
- 참조형 데이터가 ‘가변’값이라는 것은 그 내부의 프로퍼티를 변경할 때만 성립하는 것.

# 1-5 불변 객체(immutable object)

## 1-5-1 불변 객체를 만드는 간단한 방법

- 불변객체의 필요성: 값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우에 필요함.

- 객체의 가변성에 따른 문제점 해결

```jsx
var user = {
	name: 'Jaenam',
	gender: 'male'
};

var changeName = function (user, newName) {
	return {
		name: newName,
		gender: user.gender
	};
};

var user2 = changeName(user, 'Jung');

if (user != user2) {
	console.log('유저 정보가 변경되었습니다.'); //유저 정보가 변경되었습니다.
}

console.log(user.name, user2.name); //Jaenam Jung
console.log(user === user2); //false
```

⇒ changeName 함수가 새로운 객체를 반환하도록 수정

- 기존 정보를 복사해서 새로운 객체를 반환하는 함수(얕은 복사)

```jsx
var copyObject = function (target) {
	var result = {};
	for (var prop in target) {
		result[prop] = target[prop];
}

	return result;
};
```

⇒ for in 문법을 이용해 result 객체에 target 객체의 프로퍼티들을 복사하는 함수

- copyObject를 이용한 객체 복사

```jsx
var user = {
	name: 'Jaenam',
	gender: 'male'
};

var user2 = copyObject(user);
user2.name = 'Jung';

if (user != user2){
	console.log('유저 정보가 변경되었습니다.'); //유저 정보가 변경되었습니다.
}
console.log(user.name, user2.name); //Jaenam Jung
console.log(user === user2); //false
```

## 1-5-2 얕은 복사와 깊은 복사

얕은 복사: 바로 아래 단계의 값만 복사하는 방법

깊은 복사: 내부의 모든 값들을 한하나 찾아서 전부 복사하는 방법

- 중첩된 객체에 대한 얕은 복사

```jsx
var user = {
	name: 'Jaenam',
	urls: {
		portfolio: 'http://github.com/abc',
		blog: 'http://blog.com',
		facebook: 'http://facebook.com/abc'
	}
};
var user2 = copyObject(user);

user.urls.portfolio = 'http://portfolio.com';
user2.urls.blog = '';
```

→ urls의 내부 프로퍼티들은 기존 데이터를 그대로 참조하기 때문에 불변객체로 만들필요가 있음.

- 중첩된 객체에 대한 깊은 복사

```jsx
var user2 = copyObject(user);
user2.urls = copyObject(user.urls);

user.urls.portfolio = 'http://portfolio.com';
console.log(user.urls.portfolio === user2.urls.portfolio); //false

user2.urls.blog = '';
console.log(user.urls.blog === user2.urls.blog); //false
```

→ urls를 복사해서 새로운 데이터가 만들어짐.

객체의 프로퍼티 중에서 그 값이 기본형 데이터일 경우에는 그대로 복사하면 되지만 참조형 데이터는 다시 그 내부의 프로퍼티들을 복사해야 한다.

- JSON 활용하여 깊은 복사 처리하기
    - 원리: 객체를 JSON 문자열로 전환했다가 다시 JSON 객체로 변환
    - httpRequest로 받은 데이터를 저장한 객체를 복사할 때 등 순수한 정보만 다룰 때 활용하기 좋은 방법

# 1-6 undefined와 null

### 1. undefined

- 사용자가 명시적으로 지정
- 자바스크립트 엔진이 자동으로 부여

**자바스크립트 엔진이 undefined를 반환하는 경우**

1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
3. return 문이 없거나 호출되지 않는 함수의 실행 결과

**undefined 특징**

- undefined를 할당한 요소 ≠ 비어 있는 요소
- 사용자 지정 undefined
    - 하나의 값으로 동작(실존하는 데이터)
    - 고유의 키값 실존
- 자바스크립트 엔진이 반환하는 undefined
    - 값이 없음을 나타냄

### 2. null

- 명시적으로 ‘비어있음’을 나타냄
- type은 object → 자바스크립트 자체 버그